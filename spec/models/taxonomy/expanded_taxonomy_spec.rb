require "rails_helper"

module Taxonomy
  RSpec.describe ExpandedTaxonomy do
    include ContentItemHelper

    def fake_taxon(title)
      # An expanded taxonomy will always use the internal name of a taxon when
      # labelling each of its nodes.  Shorten the internal name generated by the
      # test helper to keep this spec readable.
      content_item_with_details(title).merge(
        details: { internal_name: "i-#{title}" }
      )
    end

    def home_page
      {
        base_path: "/",
        description: '',
        details: {},
        document_type: 'homepage',
        title: 'GOV.UK homepage',
        content_id: GovukTaxonomy::ROOT_CONTENT_ID
      }
    end

    # parent taxons
    let(:food) { fake_taxon("Food") }
    let(:fruits) do
      fake_taxon("Fruits").merge(
        "links" => {
          "parent_taxons" => [food]
        }
      )
    end

    # our 'root' taxon
    let(:apples) { fake_taxon("Apples") }

    # child taxons
    let(:bramley) { fake_taxon("Bramley") }
    let(:cox) { fake_taxon("Cox") }

    before do
      publishing_api_has_item(home_page)

      publishing_api_has_expanded_links(
        content_id: GovukTaxonomy::ROOT_CONTENT_ID,
        expanded_links: {
          root_taxons: [apples]
        },
      )

      publishing_api_has_item(apples)

      publishing_api_has_expanded_links(
        content_id: apples["content_id"],
        expanded_links: {
          parent_taxons: [fruits],
          child_taxons: [bramley, cox],
        },
      )

      publishing_api_has_expanded_links(
        content_id: bramley["content_id"],
        expanded_links: {
          parent_taxons: [apples]
        }
      )

      publishing_api_has_expanded_links(
        content_id: cox["content_id"],
        expanded_links: {
          parent_taxons: [apples]
        }
      )
    end

    describe 'Ask for the Homepage' do
      before :each do
        @taxonomy = ExpandedTaxonomy.new(GovukTaxonomy::ROOT_CONTENT_ID).build
      end
      it 'has no parent children' do
        expect(@taxonomy.parent_expansion.children).to be_empty
      end
      it 'has apples as direct children' do
        expect(@taxonomy.child_expansion.children.count).to eq(1)
        expect(@taxonomy.child_expansion.children.first.internal_name).to eq('i-Apples')
      end
      it 'has bramley and cox as grand children' do
        expect(@taxonomy.child_expansion.children.first.children.count).to eq(2)
        expect(@taxonomy.child_expansion.children.first.children.map(&:internal_name)).to match_array(%w[i-Bramley i-Cox])
      end
      it 'has the correct name for the home page taxon' do
        expect(@taxonomy.root_node.internal_name).to eq('Root of the taxonomy')
      end
    end

    describe "#build" do
      it "returns a representation of the taxonomy, with both parent and child taxons expanded" do
        taxonomy = ExpandedTaxonomy.new(apples["content_id"]).build

        expect(taxonomy.root_node.internal_name).to eq "i-Apples"
        expect(taxonomy.parent_expansion.map(&:internal_name)).to eq [
          'i-Apples',
          'i-Fruits',
          'i-Food',
          'Root of the taxonomy'
        ]
        expect(taxonomy.parent_expansion.map(&:depth)).to eq [0, 1, 2, 3]
        expect(taxonomy.child_expansion.map(&:internal_name)).to eq %w[
          i-Apples
          i-Bramley
          i-Cox
        ]
        expect(taxonomy.child_expansion.map(&:depth)).to eq [0, 1, 1]
      end
    end

    describe "#immediate_parents" do
      it "returns immediate parents of the root node" do
        taxonomy = ExpandedTaxonomy.new(apples["content_id"]).build

        expect(taxonomy.immediate_parents.map(&:internal_name)).to eq %w[
          i-Fruits
        ]
      end
    end

    describe "#immediate_children" do
      it "returns immediate children of the root node" do
        taxonomy = ExpandedTaxonomy.new(apples["content_id"]).build

        expect(taxonomy.immediate_children.map(&:internal_name)).to eq %w[
          i-Bramley
          i-Cox
        ]
      end
    end

    describe "#child_expansion" do
      let(:taxonomy) { ExpandedTaxonomy.new(apples["content_id"]) }

      context "when the expansion hasn't been built yet" do
        it "raises an error" do
          expect { taxonomy.child_expansion }.to raise_error(
            ExpandedTaxonomy::ExpansionNotBuiltError
          )
        end
      end

      context "when the expansion has been built" do
        it "returns the expansion" do
          taxonomy.build

          expect(taxonomy.child_expansion.map(&:internal_name)).to eq %w[i-Apples i-Bramley i-Cox]
          expect(taxonomy.child_expansion.map(&:depth)).to eq [0, 1, 1]
        end
      end

      context "given a circular dependency between taxons" do
        let(:bramley) do
          fake_taxon("Bramley").merge(
            "links" => {
              parent_taxons: [apples],
              child_taxons: [apples],
            }
          )
        end

        it "ensures the same traversal isn't rendered more than once" do
          taxonomy.build

          tree = taxonomy.child_expansion.map do |child_node|
            [child_node.depth, child_node.internal_name]
          end

          expect(tree).to eq(
            [[0, "i-Apples"], [1, "i-Bramley"], [2, "i-Apples"], [1, "i-Cox"]]
          )
        end
      end
    end

    describe "#parent_expansion" do
      let(:taxonomy) { ExpandedTaxonomy.new(apples["content_id"]) }

      context "when the expansion hasn't been built yet" do
        it "raises an error" do
          expect { taxonomy.parent_expansion }.to raise_error(
            ExpandedTaxonomy::ExpansionNotBuiltError
          )
        end
      end

      context "when the expansion has been built" do
        it "returns the expansion" do
          taxonomy.build

          expect(taxonomy.parent_expansion.map(&:internal_name)).to eq ['i-Apples', 'i-Fruits', 'i-Food', 'Root of the taxonomy']
          expect(taxonomy.parent_expansion.map(&:depth)).to eq [0, 1, 2, 3]
        end
      end
    end
  end
end
